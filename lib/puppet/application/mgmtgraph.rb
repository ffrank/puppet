require 'puppet/application'
require 'puppet/util/profiler/aggregate'

class Puppet::Application::Mgmtgraph < Puppet::Application

  option("--catalog catalog",  "-c catalog") do |arg|
    options[:catalog] = arg
  end

  def help
    <<-'HELP'

puppet-mgmtgraph(8) -- Apply Puppet manifests locally
========

SYNOPSIS
--------
Applies a standalone Puppet manifest to the local system.


USAGE
-----
puppet mgmtgraph [-h|--help] [-V|--version] [--catalog <catalog>]


DESCRIPTION
-----------
TODO


OPTIONS
-------
Note that any setting that's valid in the configuration
file is also a valid long argument. For example, 'tags' is a
valid setting, so you can specify '--tags <class>,<tag>'
as an argument.

See the configuration file documentation at
https://docs.puppetlabs.com/references/stable/configuration.html for the
full list of acceptable parameters. A commented list of all
configuration options can also be generated by running puppet with
'--genconfig'.

* --help:
  Print this help message

* --catalog:
  Translate a JSON catalog (such as one generated with 'puppet master --compile'). You can
  either specify a JSON file or pipe in JSON from standard input.

EXAMPLE
-------
    $ puppet mgmtgraph --catalog catalog.json
    $ puppet master --compile my.host.name | puppet mgmtgraph --catalog -


AUTHOR
------
Felix Frank


COPYRIGHT
---------
Copyright (c) 2016 Felix Frank, Licensed under the Apache 2.0 License

    HELP
  end

  def app_defaults
    super.merge({
      :default_file_terminus => :file_server,
    })
  end

  def run_command
    if ! options[:catalog]
      catalog = Puppet::Resource::Catalog.indirection.find(Puppet[:certname])
      translate_catalog(catalog.to_ral)
    else
      translate
    end
  end

  def translate
    if options[:catalog] == "-"
      text = $stdin.read
    else
      text = ::File.read(options[:catalog])
    end
    catalog = read_catalog(text)
    translate_catalog(catalog)
  end

  private

  def read_catalog(text)
    #begin
      catalog = Puppet::Resource::Catalog.convert_from(Puppet::Resource::Catalog.default_format,text)
      catalog = Puppet::Resource::Catalog.pson_create(catalog) unless catalog.is_a?(Puppet::Resource::Catalog)
    #rescue => detail
      #raise Puppet::Error, "Could not deserialize catalog from pson: #{detail}", detail.backtrace
    #end

    catalog.to_ral
  end

  def translate_catalog(catalog)
    result = {
      :graph => catalog.name,
      :comment => "generated from puppet catalog for #{catalog.name}",
    }
    result[:types] = {}
    edge_counter = 1

    catalog.resources.select { |res|
      case res
      when Puppet::Type::Component
        false
      when Puppet::Type::Stage
        false
      when Puppet::Type
        true
      else
        false
      end
    }.map(&:to_resource).map(&:to_data_hash).each do |resource_hash|
      next unless node = mgmt_type(resource_hash)
      result[:types][node[:type]] ||= []
      result[:types][node[:type]] << node[:content]
    end

    catalog.relationship_graph.edges.map(&:to_data_hash).each do |edge|
      from = parse_ref(edge["source"])
      to = parse_ref(edge["target"])

      next unless from and to
      next_edge = "e#{edge_counter += 1}"

      result[:edges] ||= []
      result[:edges] << { :name => next_edge, :from => from, :to => to }
    end

    puts YAML.dump desymbolize(result)
  end

  def mgmt_type(resource)
    result = {}
    resource["parameters"] ||= {} # resource w/o parameters
    case resource["type"]
    when 'File'
      result[:type] = :file
      result[:content] = {
        :name => resource["title"],
        :path => resource["parameters"][:path] || resource["title"],
      }
      if resource["parameters"][:ensure]
        result[:content][:state] = case resource["parameters"][:ensure]
          when :present, :file
            :exists
          when :absent
            :absent
        end
      end
      if resource["parameters"]["content"]
        result[:content][:content] = resource["parameters"][:content]
      end
      result
    when 'Exec'
      result[:type] = :exec
      result[:content] = {
        :name => resource["title"],
        :cmd  => resource["parameters"][:command] || resource["title"],
        :shell => resource["parameters"][:shell] || "",
        :timeout => resource["parameters"][:timeout] || 0,
        :watchcmd => "",
        :watchshell => "",
        :ifcmd => resource["parameters"][:onlyif] || "",
        :ifshell => "",
        :pollint => 0,
        :state => :present
      }
      result
    end
  end

  # From File["foo"] to { type => file, name => foo }
  def parse_ref(ref)
    if ! ref.match /^(.*)\[(.*)\]$/
      raise "unexpected reference format '#{ref}'"
    end
    type = $1.downcase
    title = $2
    return nil unless [ 'file', 'exec', 'service' ].include? type
    return { :type => type, :name => title }
  end

  def desymbolize(it)
    case it
    when Symbol
      it.to_s
    when Array
      it.collect { |x| desymbolize x }
    when Hash
      result = {}
      it.each do |k,v|
        result[desymbolize(k)] = desymbolize v
      end
      result
    else
      it
    end
  end
end
